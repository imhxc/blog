{"version":3,"sources":["webpack:///./src/posts/788836598.md","webpack:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","parentName","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"mappings":"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","file":"component---src-posts-788836598-md-4df4eab647a245b91a30.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"React.render 源码探析\",\n  \"slug\": \"React.render源码探析\",\n  \"date\": \"2021-01-19T17:01:33.000Z\"\n};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h2>{`前言`}</h2>\n    <p>{`我们经常使用过 `}<inlineCode parentName=\"p\">{`ReactDOM.render(<App />, document.body)`}</inlineCode>{`，可是你是否想过调用 `}<inlineCode parentName=\"p\">{`render`}</inlineCode>{` 的时候其所经历的整个过程，现在我们就通过源码来分析。`}</p>\n    <p>{`其主要代码在 `}<inlineCode parentName=\"p\">{`/react-dom/src/client/ReactDOM.js`}</inlineCode>{` 文件里。`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`文中的代码只会粘贴一些核心部分，完整的可以参考官方的源码文件。`}</p>\n    </blockquote>\n    <h2>{`React 最主要的三个更新方式`}</h2>\n    <p>{`在这之前，我们先来了解下 React 最主要的三个更新方式：`}</p>\n    <ul>\n      <li parentName=\"ul\">{`ReactDom.render || hydrate：`}<inlineCode parentName=\"li\">{`render`}</inlineCode>{` 和 `}<inlineCode parentName=\"li\">{`hydrate`}</inlineCode>{` 本质都一样，唯一不同的是后者为服务端渲染，后面会提到。`}</li>\n      <li parentName=\"ul\">{`setState`}</li>\n      <li parentName=\"ul\">{`forceUpdate`}</li>\n    </ul>\n    <h2>{`render 步骤`}</h2>\n    <p>{`先来看下调用 render 的一个大致步骤：`}</p>\n    <ul>\n      <li parentName=\"ul\">{`创建 ReactRoot；`}</li>\n      <li parentName=\"ul\">{`创建 FiberRoot 和 RootFiber；`}</li>\n      <li parentName=\"ul\">{`创建一个更新，创建一个，就会进入一个更新调度阶段。`}</li>\n    </ul>\n    <h2>{`ReactDOM.render 源码分析`}</h2>\n    <p>{`一般的，我们使用 React 会将组件挂在到某个节点上：`}</p>\n    <p><inlineCode parentName=\"p\">{`ReactDOM.render(<App />, document.body)`}</inlineCode></p>\n    <p>{`对于上面这段代码，我们来看 React 源码中的定义：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const ReactDOM: Object = {\n  createPortal, // Portal 组件会调用，也就是 React 传送门，如 Dialog 组件会用到\n  findDOMNode() {...},\n  hydrate() {...}, // 和 render 本质是一样的，唯一的区别在于是否会调和服用 container 里面的 HTML 节点，主要在服务端渲染的时候会使用该 API\n  render(\n    element: React$Element<any>, // React 组件\n    container: DOMContainer, // 容器，如：document.getElementId('app')\n    callback: ?Function, // 回调函数\n  ) {\n    // 返回调用 legacyRenderSubtreeIntoContainer 后的结果\n    return legacyRenderSubtreeIntoContainer(\n      null,\n      element,\n      container,\n      false, // 这里后续 forceHydrate 参数的值，一般处于服务端渲染的时候会为 true\n      callback,\n    );\n  }\n  ...\n};\n`}</code></pre>\n    <p>{`可以发现， `}<inlineCode parentName=\"p\">{`ReactDOM`}</inlineCode>{` 其实就是一个常量对象，里面包含了一些属性、方法，其中就有 `}<inlineCode parentName=\"p\">{`render`}</inlineCode>{`。`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`对于 `}<inlineCode parentName=\"p\">{`render`}</inlineCode>{` 和 `}<inlineCode parentName=\"p\">{`hydrate`}</inlineCode>{` 的唯一区别就是在调用 `}<inlineCode parentName=\"p\">{`legacyRenderSubtreeIntoContainer`}</inlineCode>{` 方法的时候传递的第四个参数不同，`}<inlineCode parentName=\"p\">{`render`}</inlineCode>{`传递的是 false，而 `}<inlineCode parentName=\"p\">{`hydrate`}</inlineCode>{` 传递的是 true。`}</p>\n    </blockquote>\n    <p>{`对于 `}<inlineCode parentName=\"p\">{`render`}</inlineCode>{` 方法，接收三个参数，对于前面两个我们都见过，但是实际上它还可以接收一个回调函数作为第三个参数。`}</p>\n    <p><inlineCode parentName=\"p\">{`render`}</inlineCode>{` 最终将这些接收的参数传递并调用 `}<inlineCode parentName=\"p\">{`legacyRenderSubtreeIntoContainer`}</inlineCode>{` 方法，然后返回该方法执行的结果。`}</p>\n    <p><strong parentName=\"p\">{`legacyRenderSubtreeIntoContainer`}</strong>{`：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>, // 父组件\n  children: ReactNodeList,\n  container: DOMContainer,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // TODO: Ensure all entry points contain this check\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  let root: Root = (container._reactRootContainer: any);\n  if (!root) {\n    // 初始化 root\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    // 如果有 callback 会进行封装调用一下\n    if (typeof callback === 'function') {\n      ...\n    }\n    // 这里会涉及到 React 中的一个批量更新的概念\n    DOMRenderer.unbatchedUpdates(() => {\n      if (parentComponent != null) {\n        // 这里基本不会走，因为在当前情况 parentComponent 永远为 null\n        ...\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    ...\n  }\n  return DOMRenderer.getPublicRootInstance(root._internalRoot);\n}\n`}</code></pre>\n    <p>{`首先会先获取 root：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`let root: Root = (container._reactRootContainer: any);\n`}</code></pre>\n    <p>{`不过正常情况，我们第一次渲染的时候，`}<inlineCode parentName=\"p\">{`container`}</inlineCode>{` 作为一个 DOM 对象，一定是不会有 `}<inlineCode parentName=\"p\">{`_reactRootContainer`}</inlineCode>{` 属性的。`}</p>\n    <p>{`所以，紧接着，React 对 root 不存在，也就是第一次渲染的情况下做了判断处理：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`if (!root) {\n  // Initial mount\n  // 这里调用 legacyCreateRootFromDOMContainer 创建了一个 root\n  root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n    container,\n    forceHydrate,\n  );\n  ...\n  // Initial mount should not be batched.\n  DOMRenderer.unbatchedUpdates(() => {\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(\n        parentComponent,\n        children,\n        callback,\n      );\n    } else {\n      root.render(children, callback);\n    }\n  });\n}\n`}</code></pre>\n    <p>{`在 root 不存在的情况，React 会调用 `}<inlineCode parentName=\"p\">{`legacyCreateRootFromDOMContainer`}</inlineCode>{` 来为其初始化一个 `}<inlineCode parentName=\"p\">{`root`}</inlineCode>{`。`}</p>\n    <p><strong parentName=\"p\">{`legacyCreateRootFromDOMContainer：`}</strong></p>\n    <p><inlineCode parentName=\"p\">{`legacyCreateRootFromDOMContainer`}</inlineCode>{` 方法最终也会返回一个 ReactRoot 实例：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function legacyCreateRootFromDOMContainer(\n  container: DOMContainer,\n  forceHydrate: boolean,\n): Root {\n  // 判断是不是服务端渲染\n  const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // 如果不是服务端渲染，则通过循环删除 container 子节点\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n  // Legacy roots are not async by default.\n  const isConcurrent = false;\n  // 返回一个 ReactRoot 实例\n  return new ReactRoot(container, isConcurrent, shouldHydrate);\n}\n`}</code></pre>\n    <p>{`对于 `}<inlineCode parentName=\"p\">{`forceHydrate`}</inlineCode>{` 前面也提到了，就是用来区分是不是服务端渲染，如果使得话，就会调用 `}<inlineCode parentName=\"p\">{`shouldHydrateDueToLegacyHeuristic`}</inlineCode>{` 方法：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function shouldHydrateDueToLegacyHeuristic(container) {\n  const rootElement = getReactRootElementInContainer(container);\n  return !!(\n    // 是不是存在\n    rootElement &&\n    // 是否是普通的 element type\n    rootElement.nodeType === ELEMENT_NODE && \n    // 是否有 ROOT_ATTRIBUTE_NAME，这里 ROOT_ATTRIBUTE_NAME 值为 data-reactroot，服务端渲染会在 root 节点添加该属性，以此来标识该应用是由服务端渲染的\n    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME) \n  );\n}\n`}</code></pre>\n    <p>{`该方法通过判断来决定是否需要进行服务端渲染。`}</p>\n    <p>{`然后 `}<inlineCode parentName=\"p\">{`legacyCreateRootFromDOMContainer`}</inlineCode>{`，中，通过 `}<inlineCode parentName=\"p\">{`shouldHydrate`}</inlineCode>{` 来标识是否是服务端渲染，如果不是的话，会通过一个循环来删除 `}<inlineCode parentName=\"p\">{`container`}</inlineCode>{` 节点下的所有子节点：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`if (!shouldHydrate) {\n  let warned = false;\n  let rootSibling;\n  while ((rootSibling = container.lastChild)) {\n    container.removeChild(rootSibling);\n  }\n}\n`}</code></pre>\n    <p>{`最终，`}<inlineCode parentName=\"p\">{`legacyCreateRootFromDOMContainer`}</inlineCode>{` 返回一个实例：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`return new ReactRoot(container, isConcurrent, shouldHydrate);\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`对于 ReactRoot，你可以查看其方法定义，会发现并没有做太多的操作，主要还是调用了 `}<inlineCode parentName=\"p\">{`DOMRender`}</inlineCode>{` 的一个方法来生成 `}<inlineCode parentName=\"p\">{`root`}</inlineCode>{`。\n而 `}<inlineCode parentName=\"p\">{`DOMRender`}</inlineCode>{` 引自 `}<inlineCode parentName=\"p\">{`react-reconciler`}</inlineCode>{` ：`}<inlineCode parentName=\"p\">{`import * as DOMRenderer from 'react-reconciler/inline.dom';`}</inlineCode>{`，`}<inlineCode parentName=\"p\">{`react-reconciler`}</inlineCode>{` 是 React 中非常重要的模块，`}<strong parentName=\"p\">{`它会去操作和平台无关的一些节点的调和、以及任务调度等。`}</strong>{`\n这里我们可以简单的了解下，调用 `}<inlineCode parentName=\"p\">{`DOMRenderer.createContainer`}</inlineCode>{` 后，最终会返回一个 `}<inlineCode parentName=\"p\">{`FiberRoot`}</inlineCode>{`，也就进入到了我们前面提到的第二部。`}</p>\n    </blockquote>\n    <p>{`回到最开始的地方，也就是 ReactDOM 对象中的 `}<inlineCode parentName=\"p\">{`render`}</inlineCode>{` 属性方法，接着往下看，其会继续调用 `}<inlineCode parentName=\"p\">{`root.render(children, callback);`}</inlineCode>{`,对于 `}<inlineCode parentName=\"p\">{`root.legacy_renderSubtreeIntoContainer`}</inlineCode>{` 在这里是不会调用的，因为 `}<inlineCode parentName=\"p\">{`parentComponent`}</inlineCode>{` 永远不存在：`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`DOMRenderer.unbatchedUpdates(() => {\n  if (parentComponent != null) {\n    root.legacy_renderSubtreeIntoContainer(\n      parentComponent,\n      children,\n      callback,\n    );\n  } else {\n    root.render(children, callback);\n  }\n});\n`}</code></pre>\n    <p><strong parentName=\"p\">{`ReactBatch.prototype.render：`}</strong></p>\n    <p><inlineCode parentName=\"p\">{`root.render(children, callback);`}</inlineCode>{` 所调用的就是 `}<inlineCode parentName=\"p\">{`ReactBatch.prototype.render`}</inlineCode>{`：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`ReactBatch.prototype.render = function(children: ReactNodeList) {\n  invariant(\n    this._defer,\n    'batch.render: Cannot render a batch that already committed.',\n  );\n  this._hasChildren = true;\n  this._children = children;\n  const internalRoot = this._root._internalRoot;\n  const expirationTime = this._expirationTime;\n  const work = new ReactWork();\n  DOMRenderer.updateContainerAtExpirationTime(\n    children,\n    internalRoot,\n    null,\n    expirationTime,\n    work._onCommit,\n  );\n  return work;\n};\n`}</code></pre>\n    <p>{`对于 `}<inlineCode parentName=\"p\">{`updateContainerAtExpirationTime`}</inlineCode>{` 这设计到 React 另外一个重要的概念，即调度更新、优先级，这个需要我们单独的去了解下。 `}</p>\n    <p>{`这里简单提一下，简单的看下该方法的源码，会发现其会调用 `}<inlineCode parentName=\"p\">{`scheduleRootUpdate`}</inlineCode>{`，这个非常重要，也就是要开始调度了。 其首先会生成一个 `}<inlineCode parentName=\"p\">{`update`}</inlineCode>{`，因为在 React 中，不管是 `}<inlineCode parentName=\"p\">{`setState`}</inlineCode>{` 还是 `}<inlineCode parentName=\"p\">{`ReactDOM.render`}</inlineCode>{` 造成的更新，都会生成一个 update 对象，并且赋值给 `}<inlineCode parentName=\"p\">{`Fiber.updateQueue`}</inlineCode>{`，最终进入 `}<inlineCode parentName=\"p\">{`scheduleWork。`}</inlineCode></p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"sourceRoot":""}