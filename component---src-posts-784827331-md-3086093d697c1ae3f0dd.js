(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{EOD6:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return m}));var a=t("zLVn"),p=(t("q1tI"),t("7ljp")),c={title:"TypeScript 联合类型",slug:784827331,date:"2021-01-13T14:25:39.000Z",tags:["标签"],categories:["未分类"],keywords:["关键册"]},l={_frontmatter:c};function m(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(p.mdx)("wrapper",Object.assign({},l,t,{components:n,mdxType:"MDXLayout"}),Object(p.mdx)("h2",null,"什么是联合类型"),Object(p.mdx)("p",null,Object(p.mdx)("em",{parentName:"p"},"联合类型（Union Type）"),"可以通过管道符 ",Object(p.mdx)("inlineCode",{parentName:"p"},"|")," 将变量设置多种类型。"),Object(p.mdx)("p",null,"比如最常见的，你可能在你的代码中这么写过：",Object(p.mdx)("inlineCode",{parentName:"p"},"let value: string | number"),"，这其实是就是一个简单的联合类型，它允许为一个变量设置多种可能类型。"),Object(p.mdx)("p",null,"这里我讲解以下特殊的场景。"),Object(p.mdx)("h2",null,"联合类型在判断中的体现"),Object(p.mdx)("p",null,"先看下面的代码："),Object(p.mdx)("pre",null,Object(p.mdx)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"interface Square {\n  kind: 'square'\n  size: number\n}\ninterface Rectangle {\n  kind: 'rectangle'\n  width: number\n  height: number\n}\n\ntype Shape = Square | Rectangle\n")),Object(p.mdx)("p",null,"这里分别定义了 ",Object(p.mdx)("inlineCode",{parentName:"p"},"Square")," 和 ",Object(p.mdx)("inlineCode",{parentName:"p"},"Rectangle"),"  两个类型接口，同时定义了一个 Shape 联合类型。"),Object(p.mdx)("p",null,"在一些 ",Object(p.mdx)("inlineCode",{parentName:"p"},"if...else")," 判断中，联合类型的好处就体现出来了。"),Object(p.mdx)("pre",null,Object(p.mdx)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function area(shape: Shape) {\n  if (shape.kind === 'square') {\n    // 这里 TS 会推断出参数 shape 为 Square\n    // 所以，这里你的 shapre 对象只能取到 Square 接口上定义的属性\n    // shape.width 可以安全调用，因为 Square 接口上已经定义了该属性\n    return shape.width\n  } else {\n    // 在 else 中，TS 会推断出 shape 为 Rectangle\n    return shape.width * shape.height\n  }\n}\n")),Object(p.mdx)("p",null,"在 VSCODE 中，鼠标放在 ",Object(p.mdx)("inlineCode",{parentName:"p"},"else")," 条件中的 ",Object(p.mdx)("inlineCode",{parentName:"p"},"shape")," 对象上，可以看到，TS 正确推断出了 shape 的类型："),Object(p.mdx)("p",null,Object(p.mdx)("img",Object.assign({parentName:"p"},{src:"https://user-images.githubusercontent.com/16508338/104416861-737ad680-55af-11eb-984f-bf332dcb1336.png",alt:"image"}))),Object(p.mdx)("p",null,Object(p.mdx)("strong",{parentName:"p"},"联合类型的强大和美妙之处就在于此，但远不止于此。")),Object(p.mdx)("h2",null,"更加详细的推断"),Object(p.mdx)("p",null,"我们依旧使用前定义的 ",Object(p.mdx)("inlineCode",{parentName:"p"},"Shape")," 类型，但是对 ",Object(p.mdx)("inlineCode",{parentName:"p"},"area")," 函数做一些修改："),Object(p.mdx)("pre",null,Object(p.mdx)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function area(shape: Shape) {\n  if (shape.kind === 'square') {\n    return shape.width\n  }\n  // 我们删除了 else，即抛弃了当 shape 类型为 Rectangle 的时候的处理\n}\n")),Object(p.mdx)("p",null,"我在这里，我不小心忘记处理了 ",Object(p.mdx)("inlineCode",{parentName:"p"},"shape")," 类型为 ",Object(p.mdx)("inlineCode",{parentName:"p"},"Rectangle")," 的情况。"),Object(p.mdx)("p",null,"如何解决这种问题呢？"),Object(p.mdx)("p",null,"我们可以利用",Object(p.mdx)("em",{parentName:"p"},"简单的向下思想，来确保块中的类型被推断为与 ",Object(p.mdx)("inlineCode",{parentName:"em"},"never")," 类型兼容的类型"),"。"),Object(p.mdx)("p",null,"举个 🌰。"),Object(p.mdx)("pre",null,Object(p.mdx)("code",Object.assign({parentName:"pre"},{className:"language-js"}),"function area(shape: Shape) {\n  if (shape.kind === 'square') {\n    return shape.width\n  } else if(shape.kind === 'rectangle') {\n    // 由于后面 else 条件中的代码，导致你必须添加该处理\n    return shape.width * shape.height\n  }else {\n    // 通过定义一个将 shape 赋值给另外一个变量，并且将变量定义为 never；\n    // 这将强制你去处理每一个边界情况\n    const _exhaustiveCheck: never = shape\n    return _exhaustiveCheck\n  }\n}\n")),Object(p.mdx)("p",null,"在编辑器中，如果你不小心忽略了对某个类型的处理，那么 TS 会立即提示你："),Object(p.mdx)("p",null,Object(p.mdx)("img",Object.assign({parentName:"p"},{src:"https://user-images.githubusercontent.com/16508338/104420032-3fee7b00-55b4-11eb-886a-bdbadc82c0a1.png",alt:"image"}))),Object(p.mdx)("p",null,Object(p.mdx)("strong",{parentName:"p"},"该约束同样适用于 ",Object(p.mdx)("inlineCode",{parentName:"strong"},"switch")," 语法。")),Object(p.mdx)("h2",null,"strictNullChecks"),Object(p.mdx)("p",null,"如果你 ",Object(p.mdx)("inlineCode",{parentName:"p"},"tsconfig.json")," 文件中使用了 ",Object(p.mdx)("inlineCode",{parentName:"p"},"strictNullChecks"),"，不要忘记返回 ",Object(p.mdx)("inlineCode",{parentName:"p"},"_exhaustiveCheck")," 变量，否则 TS 可能会推断返回值为 ",Object(p.mdx)("inlineCode",{parentName:"p"},"undefined"),"。"),Object(p.mdx)("h2",null,"总结"),Object(p.mdx)("ol",null,Object(p.mdx)("li",{parentName:"ol"},"联合类型通过管道符来实现；"),Object(p.mdx)("li",{parentName:"ol"},"联合类型可以在一些场景下（比如 ",Object(p.mdx)("inlineCode",{parentName:"li"},"if...else"),"）自动推断出当前类型；"),Object(p.mdx)("li",{parentName:"ol"},"将联合类型的对象赋值给 ",Object(p.mdx)("inlineCode",{parentName:"li"},"never")," 类型的对象，可以避免遗漏一些条件判断；")))}m.isMDXComponent=!0},zLVn:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,p={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(p[t]=e[t]);return p}t.d(n,"a",(function(){return a}))}}]);
//# sourceMappingURL=component---src-posts-784827331-md-3086093d697c1ae3f0dd.js.map