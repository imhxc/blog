{"version":3,"sources":["webpack:///./src/posts/784827331.md","webpack:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","parentName","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"mappings":"+NAOaA,EAAe,CAC1B,MAAS,kBACT,KAAQ,UACR,KAAQ,2BACR,KAAQ,CAAC,MACT,WAAc,CAAC,OACf,SAAY,CAAC,QAETC,EAAc,CAClBD,gBAGa,SAASE,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,cALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAC5E,mCACA,uBAAG,oBAAIC,WAAW,KAAf,oBAAH,WAA2D,4BAAYA,WAAW,KAAvB,KAA3D,eACA,+CAA4B,4BAAYA,WAAW,KAAvB,8BAA5B,sCACA,wCACA,uCACA,mCACA,yBAAK,oCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,mLAcL,kCAAe,4BAAYA,WAAW,KAAvB,UAAf,MAAwE,4BAAYA,WAAW,KAAvB,aAAxE,gCACA,8BAAW,4BAAYA,WAAW,KAAvB,aAAX,uBACA,yBAAK,oCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,uUAcL,0CAAuB,4BAAYA,WAAW,KAAvB,QAAvB,SAAiF,4BAAYA,WAAW,KAAvB,SAAjF,kCACA,uBAAG,mCAAKA,WAAW,KAAQ,CACvB,IAAO,wGACP,IAAO,YAEX,uBAAG,wBAAQA,WAAW,KAAnB,6BACH,mCACA,qCAAkB,4BAAYA,WAAW,KAAvB,SAAlB,WAA+E,4BAAYA,WAAW,KAAvB,QAA/E,aACA,yBAAK,oCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wJASL,yCAAsB,4BAAYA,WAAW,KAAvB,SAAtB,QAAgF,4BAAYA,WAAW,KAAvB,aAAhF,SACA,qCACA,gCAAa,oBAAIA,WAAW,KAAf,yBAA6C,4BAAYA,WAAW,MAAvB,SAA7C,YAAb,KACA,iCACA,yBAAK,oCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,uXAgBL,gEACA,uBAAG,mCAAKA,WAAW,KAAQ,CACvB,IAAO,wGACP,IAAO,YAEX,uBAAG,wBAAQA,WAAW,KAAnB,YAAoC,4BAAYA,WAAW,UAAvB,UAApC,SACH,4CACA,8BAAW,4BAAYA,WAAW,KAAvB,iBAAX,WAAgF,4BAAYA,WAAW,KAAvB,oBAAhF,WAAwJ,4BAAYA,WAAW,KAAvB,oBAAxJ,uBAA4O,4BAAYA,WAAW,KAAvB,aAA5O,KACA,8BACA,wBACE,oBAAIA,WAAW,MAAf,iBACA,oBAAIA,WAAW,MAAf,mBAAwC,4BAAYA,WAAW,MAAvB,aAAxC,eACA,oBAAIA,WAAW,MAAf,eAAoC,4BAAYA,WAAW,MAAvB,SAApC,0BAMNJ,EAAWK,gBAAiB,G,kCCnHb,SAASC,EAA8BC,EAAQC,GAC5D,GAAc,MAAVD,EAAgB,MAAO,GAC3B,IAEIE,EAAKC,EAFLC,EAAS,GACTC,EAAaC,OAAOC,KAAKP,GAG7B,IAAKG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,IAGvB,OAAOE,EAZT","file":"component---src-posts-784827331-md-3086093d697c1ae3f0dd.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"TypeScript 联合类型\",\n  \"slug\": 784827331,\n  \"date\": \"2021-01-13T14:25:39.000Z\",\n  \"tags\": [\"标签\"],\n  \"categories\": [\"未分类\"],\n  \"keywords\": [\"关键册\"]\n};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h2>{`什么是联合类型`}</h2>\n    <p><em parentName=\"p\">{`联合类型（Union Type）`}</em>{`可以通过管道符 `}<inlineCode parentName=\"p\">{`|`}</inlineCode>{` 将变量设置多种类型。`}</p>\n    <p>{`比如最常见的，你可能在你的代码中这么写过：`}<inlineCode parentName=\"p\">{`let value: string | number`}</inlineCode>{`，这其实是就是一个简单的联合类型，它允许为一个变量设置多种可能类型。`}</p>\n    <p>{`这里我讲解以下特殊的场景。`}</p>\n    <h2>{`联合类型在判断中的体现`}</h2>\n    <p>{`先看下面的代码：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`interface Square {\n  kind: 'square'\n  size: number\n}\ninterface Rectangle {\n  kind: 'rectangle'\n  width: number\n  height: number\n}\n\ntype Shape = Square | Rectangle\n`}</code></pre>\n    <p>{`这里分别定义了 `}<inlineCode parentName=\"p\">{`Square`}</inlineCode>{` 和 `}<inlineCode parentName=\"p\">{`Rectangle`}</inlineCode>{`  两个类型接口，同时定义了一个 Shape 联合类型。`}</p>\n    <p>{`在一些 `}<inlineCode parentName=\"p\">{`if...else`}</inlineCode>{` 判断中，联合类型的好处就体现出来了。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function area(shape: Shape) {\n  if (shape.kind === 'square') {\n    // 这里 TS 会推断出参数 shape 为 Square\n    // 所以，这里你的 shapre 对象只能取到 Square 接口上定义的属性\n    // shape.width 可以安全调用，因为 Square 接口上已经定义了该属性\n    return shape.width\n  } else {\n    // 在 else 中，TS 会推断出 shape 为 Rectangle\n    return shape.width * shape.height\n  }\n}\n`}</code></pre>\n    <p>{`在 VSCODE 中，鼠标放在 `}<inlineCode parentName=\"p\">{`else`}</inlineCode>{` 条件中的 `}<inlineCode parentName=\"p\">{`shape`}</inlineCode>{` 对象上，可以看到，TS 正确推断出了 shape 的类型：`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/16508338/104416861-737ad680-55af-11eb-984f-bf332dcb1336.png\",\n        \"alt\": \"image\"\n      }}></img></p>\n    <p><strong parentName=\"p\">{`联合类型的强大和美妙之处就在于此，但远不止于此。`}</strong></p>\n    <h2>{`更加详细的推断`}</h2>\n    <p>{`我们依旧使用前定义的 `}<inlineCode parentName=\"p\">{`Shape`}</inlineCode>{` 类型，但是对 `}<inlineCode parentName=\"p\">{`area`}</inlineCode>{` 函数做一些修改：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function area(shape: Shape) {\n  if (shape.kind === 'square') {\n    return shape.width\n  }\n  // 我们删除了 else，即抛弃了当 shape 类型为 Rectangle 的时候的处理\n}\n`}</code></pre>\n    <p>{`我在这里，我不小心忘记处理了 `}<inlineCode parentName=\"p\">{`shape`}</inlineCode>{` 类型为 `}<inlineCode parentName=\"p\">{`Rectangle`}</inlineCode>{` 的情况。`}</p>\n    <p>{`如何解决这种问题呢？`}</p>\n    <p>{`我们可以利用`}<em parentName=\"p\">{`简单的向下思想，来确保块中的类型被推断为与 `}<inlineCode parentName=\"em\">{`never`}</inlineCode>{` 类型兼容的类型`}</em>{`。`}</p>\n    <p>{`举个 🌰。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function area(shape: Shape) {\n  if (shape.kind === 'square') {\n    return shape.width\n  } else if(shape.kind === 'rectangle') {\n    // 由于后面 else 条件中的代码，导致你必须添加该处理\n    return shape.width * shape.height\n  }else {\n    // 通过定义一个将 shape 赋值给另外一个变量，并且将变量定义为 never；\n    // 这将强制你去处理每一个边界情况\n    const _exhaustiveCheck: never = shape\n    return _exhaustiveCheck\n  }\n}\n`}</code></pre>\n    <p>{`在编辑器中，如果你不小心忽略了对某个类型的处理，那么 TS 会立即提示你：`}</p>\n    <p><img parentName=\"p\" {...{\n        \"src\": \"https://user-images.githubusercontent.com/16508338/104420032-3fee7b00-55b4-11eb-886a-bdbadc82c0a1.png\",\n        \"alt\": \"image\"\n      }}></img></p>\n    <p><strong parentName=\"p\">{`该约束同样适用于 `}<inlineCode parentName=\"strong\">{`switch`}</inlineCode>{` 语法。`}</strong></p>\n    <h2>{`strictNullChecks`}</h2>\n    <p>{`如果你 `}<inlineCode parentName=\"p\">{`tsconfig.json`}</inlineCode>{` 文件中使用了 `}<inlineCode parentName=\"p\">{`strictNullChecks`}</inlineCode>{`，不要忘记返回 `}<inlineCode parentName=\"p\">{`_exhaustiveCheck`}</inlineCode>{` 变量，否则 TS 可能会推断返回值为 `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`。`}</p>\n    <h2>{`总结`}</h2>\n    <ol>\n      <li parentName=\"ol\">{`联合类型通过管道符来实现；`}</li>\n      <li parentName=\"ol\">{`联合类型可以在一些场景下（比如 `}<inlineCode parentName=\"li\">{`if...else`}</inlineCode>{`）自动推断出当前类型；`}</li>\n      <li parentName=\"ol\">{`将联合类型的对象赋值给 `}<inlineCode parentName=\"li\">{`never`}</inlineCode>{` 类型的对象，可以避免遗漏一些条件判断；`}</li>\n    </ol>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"sourceRoot":""}