(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{mAUw:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return o})),t.d(n,"default",(function(){return l}));var a=t("zLVn"),r=(t("q1tI"),t("7ljp")),o={title:"React.render 源码探析",slug:"React.render源码探析",date:"2021-01-19T17:01:33.000Z"},c={_frontmatter:o};function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.mdx)("wrapper",Object.assign({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.mdx)("h2",null,"前言"),Object(r.mdx)("p",null,"我们经常使用过 ",Object(r.mdx)("inlineCode",{parentName:"p"},"ReactDOM.render(<App />, document.body)"),"，可是你是否想过调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"render")," 的时候其所经历的整个过程，现在我们就通过源码来分析。"),Object(r.mdx)("p",null,"其主要代码在 ",Object(r.mdx)("inlineCode",{parentName:"p"},"/react-dom/src/client/ReactDOM.js")," 文件里。"),Object(r.mdx)("blockquote",null,Object(r.mdx)("p",{parentName:"blockquote"},"文中的代码只会粘贴一些核心部分，完整的可以参考官方的源码文件。")),Object(r.mdx)("h2",null,"React 最主要的三个更新方式"),Object(r.mdx)("p",null,"在这之前，我们先来了解下 React 最主要的三个更新方式："),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},"ReactDom.render || hydrate：",Object(r.mdx)("inlineCode",{parentName:"li"},"render")," 和 ",Object(r.mdx)("inlineCode",{parentName:"li"},"hydrate")," 本质都一样，唯一不同的是后者为服务端渲染，后面会提到。"),Object(r.mdx)("li",{parentName:"ul"},"setState"),Object(r.mdx)("li",{parentName:"ul"},"forceUpdate")),Object(r.mdx)("h2",null,"render 步骤"),Object(r.mdx)("p",null,"先来看下调用 render 的一个大致步骤："),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},"创建 ReactRoot；"),Object(r.mdx)("li",{parentName:"ul"},"创建 FiberRoot 和 RootFiber；"),Object(r.mdx)("li",{parentName:"ul"},"创建一个更新，创建一个，就会进入一个更新调度阶段。")),Object(r.mdx)("h2",null,"ReactDOM.render 源码分析"),Object(r.mdx)("p",null,"一般的，我们使用 React 会将组件挂在到某个节点上："),Object(r.mdx)("p",null,Object(r.mdx)("inlineCode",{parentName:"p"},"ReactDOM.render(<App />, document.body)")),Object(r.mdx)("p",null,"对于上面这段代码，我们来看 React 源码中的定义："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"const ReactDOM: Object = {\n  createPortal, // Portal 组件会调用，也就是 React 传送门，如 Dialog 组件会用到\n  findDOMNode() {...},\n  hydrate() {...}, // 和 render 本质是一样的，唯一的区别在于是否会调和服用 container 里面的 HTML 节点，主要在服务端渲染的时候会使用该 API\n  render(\n    element: React$Element<any>, // React 组件\n    container: DOMContainer, // 容器，如：document.getElementId('app')\n    callback: ?Function, // 回调函数\n  ) {\n    // 返回调用 legacyRenderSubtreeIntoContainer 后的结果\n    return legacyRenderSubtreeIntoContainer(\n      null,\n      element,\n      container,\n      false, // 这里后续 forceHydrate 参数的值，一般处于服务端渲染的时候会为 true\n      callback,\n    );\n  }\n  ...\n};\n")),Object(r.mdx)("p",null,"可以发现， ",Object(r.mdx)("inlineCode",{parentName:"p"},"ReactDOM")," 其实就是一个常量对象，里面包含了一些属性、方法，其中就有 ",Object(r.mdx)("inlineCode",{parentName:"p"},"render"),"。"),Object(r.mdx)("blockquote",null,Object(r.mdx)("p",{parentName:"blockquote"},"对于 ",Object(r.mdx)("inlineCode",{parentName:"p"},"render")," 和 ",Object(r.mdx)("inlineCode",{parentName:"p"},"hydrate")," 的唯一区别就是在调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"legacyRenderSubtreeIntoContainer")," 方法的时候传递的第四个参数不同，",Object(r.mdx)("inlineCode",{parentName:"p"},"render"),"传递的是 false，而 ",Object(r.mdx)("inlineCode",{parentName:"p"},"hydrate")," 传递的是 true。")),Object(r.mdx)("p",null,"对于 ",Object(r.mdx)("inlineCode",{parentName:"p"},"render")," 方法，接收三个参数，对于前面两个我们都见过，但是实际上它还可以接收一个回调函数作为第三个参数。"),Object(r.mdx)("p",null,Object(r.mdx)("inlineCode",{parentName:"p"},"render")," 最终将这些接收的参数传递并调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"legacyRenderSubtreeIntoContainer")," 方法，然后返回该方法执行的结果。"),Object(r.mdx)("p",null,Object(r.mdx)("strong",{parentName:"p"},"legacyRenderSubtreeIntoContainer"),"："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"function legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>, // 父组件\n  children: ReactNodeList,\n  container: DOMContainer,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // TODO: Ensure all entry points contain this check\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  let root: Root = (container._reactRootContainer: any);\n  if (!root) {\n    // 初始化 root\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    // 如果有 callback 会进行封装调用一下\n    if (typeof callback === 'function') {\n      ...\n    }\n    // 这里会涉及到 React 中的一个批量更新的概念\n    DOMRenderer.unbatchedUpdates(() => {\n      if (parentComponent != null) {\n        // 这里基本不会走，因为在当前情况 parentComponent 永远为 null\n        ...\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    ...\n  }\n  return DOMRenderer.getPublicRootInstance(root._internalRoot);\n}\n")),Object(r.mdx)("p",null,"首先会先获取 root："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"let root: Root = (container._reactRootContainer: any);\n")),Object(r.mdx)("p",null,"不过正常情况，我们第一次渲染的时候，",Object(r.mdx)("inlineCode",{parentName:"p"},"container")," 作为一个 DOM 对象，一定是不会有 ",Object(r.mdx)("inlineCode",{parentName:"p"},"_reactRootContainer")," 属性的。"),Object(r.mdx)("p",null,"所以，紧接着，React 对 root 不存在，也就是第一次渲染的情况下做了判断处理："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"if (!root) {\n  // Initial mount\n  // 这里调用 legacyCreateRootFromDOMContainer 创建了一个 root\n  root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n    container,\n    forceHydrate,\n  );\n  ...\n  // Initial mount should not be batched.\n  DOMRenderer.unbatchedUpdates(() => {\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(\n        parentComponent,\n        children,\n        callback,\n      );\n    } else {\n      root.render(children, callback);\n    }\n  });\n}\n")),Object(r.mdx)("p",null,"在 root 不存在的情况，React 会调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"legacyCreateRootFromDOMContainer")," 来为其初始化一个 ",Object(r.mdx)("inlineCode",{parentName:"p"},"root"),"。"),Object(r.mdx)("p",null,Object(r.mdx)("strong",{parentName:"p"},"legacyCreateRootFromDOMContainer：")),Object(r.mdx)("p",null,Object(r.mdx)("inlineCode",{parentName:"p"},"legacyCreateRootFromDOMContainer")," 方法最终也会返回一个 ReactRoot 实例："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"function legacyCreateRootFromDOMContainer(\n  container: DOMContainer,\n  forceHydrate: boolean,\n): Root {\n  // 判断是不是服务端渲染\n  const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // 如果不是服务端渲染，则通过循环删除 container 子节点\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n  // Legacy roots are not async by default.\n  const isConcurrent = false;\n  // 返回一个 ReactRoot 实例\n  return new ReactRoot(container, isConcurrent, shouldHydrate);\n}\n")),Object(r.mdx)("p",null,"对于 ",Object(r.mdx)("inlineCode",{parentName:"p"},"forceHydrate")," 前面也提到了，就是用来区分是不是服务端渲染，如果使得话，就会调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"shouldHydrateDueToLegacyHeuristic")," 方法："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"function shouldHydrateDueToLegacyHeuristic(container) {\n  const rootElement = getReactRootElementInContainer(container);\n  return !!(\n    // 是不是存在\n    rootElement &&\n    // 是否是普通的 element type\n    rootElement.nodeType === ELEMENT_NODE && \n    // 是否有 ROOT_ATTRIBUTE_NAME，这里 ROOT_ATTRIBUTE_NAME 值为 data-reactroot，服务端渲染会在 root 节点添加该属性，以此来标识该应用是由服务端渲染的\n    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME) \n  );\n}\n")),Object(r.mdx)("p",null,"该方法通过判断来决定是否需要进行服务端渲染。"),Object(r.mdx)("p",null,"然后 ",Object(r.mdx)("inlineCode",{parentName:"p"},"legacyCreateRootFromDOMContainer"),"，中，通过 ",Object(r.mdx)("inlineCode",{parentName:"p"},"shouldHydrate")," 来标识是否是服务端渲染，如果不是的话，会通过一个循环来删除 ",Object(r.mdx)("inlineCode",{parentName:"p"},"container")," 节点下的所有子节点："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"if (!shouldHydrate) {\n  let warned = false;\n  let rootSibling;\n  while ((rootSibling = container.lastChild)) {\n    container.removeChild(rootSibling);\n  }\n}\n")),Object(r.mdx)("p",null,"最终，",Object(r.mdx)("inlineCode",{parentName:"p"},"legacyCreateRootFromDOMContainer")," 返回一个实例："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"return new ReactRoot(container, isConcurrent, shouldHydrate);\n")),Object(r.mdx)("blockquote",null,Object(r.mdx)("p",{parentName:"blockquote"},"对于 ReactRoot，你可以查看其方法定义，会发现并没有做太多的操作，主要还是调用了 ",Object(r.mdx)("inlineCode",{parentName:"p"},"DOMRender")," 的一个方法来生成 ",Object(r.mdx)("inlineCode",{parentName:"p"},"root"),"。\n而 ",Object(r.mdx)("inlineCode",{parentName:"p"},"DOMRender")," 引自 ",Object(r.mdx)("inlineCode",{parentName:"p"},"react-reconciler")," ：",Object(r.mdx)("inlineCode",{parentName:"p"},"import * as DOMRenderer from 'react-reconciler/inline.dom';"),"，",Object(r.mdx)("inlineCode",{parentName:"p"},"react-reconciler")," 是 React 中非常重要的模块，",Object(r.mdx)("strong",{parentName:"p"},"它会去操作和平台无关的一些节点的调和、以及任务调度等。"),"\n这里我们可以简单的了解下，调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"DOMRenderer.createContainer")," 后，最终会返回一个 ",Object(r.mdx)("inlineCode",{parentName:"p"},"FiberRoot"),"，也就进入到了我们前面提到的第二部。")),Object(r.mdx)("p",null,"回到最开始的地方，也就是 ReactDOM 对象中的 ",Object(r.mdx)("inlineCode",{parentName:"p"},"render")," 属性方法，接着往下看，其会继续调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"root.render(children, callback);"),",对于 ",Object(r.mdx)("inlineCode",{parentName:"p"},"root.legacy_renderSubtreeIntoContainer")," 在这里是不会调用的，因为 ",Object(r.mdx)("inlineCode",{parentName:"p"},"parentComponent")," 永远不存在："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{}),"DOMRenderer.unbatchedUpdates(() => {\n  if (parentComponent != null) {\n    root.legacy_renderSubtreeIntoContainer(\n      parentComponent,\n      children,\n      callback,\n    );\n  } else {\n    root.render(children, callback);\n  }\n});\n")),Object(r.mdx)("p",null,Object(r.mdx)("strong",{parentName:"p"},"ReactBatch.prototype.render：")),Object(r.mdx)("p",null,Object(r.mdx)("inlineCode",{parentName:"p"},"root.render(children, callback);")," 所调用的就是 ",Object(r.mdx)("inlineCode",{parentName:"p"},"ReactBatch.prototype.render"),"："),Object(r.mdx)("pre",null,Object(r.mdx)("code",Object.assign({parentName:"pre"},{className:"language-javascript"}),"ReactBatch.prototype.render = function(children: ReactNodeList) {\n  invariant(\n    this._defer,\n    'batch.render: Cannot render a batch that already committed.',\n  );\n  this._hasChildren = true;\n  this._children = children;\n  const internalRoot = this._root._internalRoot;\n  const expirationTime = this._expirationTime;\n  const work = new ReactWork();\n  DOMRenderer.updateContainerAtExpirationTime(\n    children,\n    internalRoot,\n    null,\n    expirationTime,\n    work._onCommit,\n  );\n  return work;\n};\n")),Object(r.mdx)("p",null,"对于 ",Object(r.mdx)("inlineCode",{parentName:"p"},"updateContainerAtExpirationTime")," 这设计到 React 另外一个重要的概念，即调度更新、优先级，这个需要我们单独的去了解下。 "),Object(r.mdx)("p",null,"这里简单提一下，简单的看下该方法的源码，会发现其会调用 ",Object(r.mdx)("inlineCode",{parentName:"p"},"scheduleRootUpdate"),"，这个非常重要，也就是要开始调度了。 其首先会生成一个 ",Object(r.mdx)("inlineCode",{parentName:"p"},"update"),"，因为在 React 中，不管是 ",Object(r.mdx)("inlineCode",{parentName:"p"},"setState")," 还是 ",Object(r.mdx)("inlineCode",{parentName:"p"},"ReactDOM.render")," 造成的更新，都会生成一个 update 对象，并且赋值给 ",Object(r.mdx)("inlineCode",{parentName:"p"},"Fiber.updateQueue"),"，最终进入 ",Object(r.mdx)("inlineCode",{parentName:"p"},"scheduleWork。")))}l.isMDXComponent=!0},zLVn:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}t.d(n,"a",(function(){return a}))}}]);
//# sourceMappingURL=component---src-posts-788836598-md-4df4eab647a245b91a30.js.map